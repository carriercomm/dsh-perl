.\"  -*- nroff -*-
.\"
.\" Author: Matthew T. Piotrowski <mtp22@cornell.edu>
.\" Copyright (c) 2001 Matthew T. Piotrowski <mtp22@cornell.edu>, 
.\"                    All rights reserved
.\"
.\" Help with nroff syntax from the OpenSSH manpage, v1.99
.\"
.\" This manpage can be used and distributed under the same terms as
 \" dsh itself.
.\"
.\" $Id$
.Dd July 10, 2001
.Dt DSH 1
.Sh NAME
.Nm dsh
.Nd the distributed shell
.Sh SYNOPSIS
.Nm dsh
.Op Fl a
.Op Fl e Ar 'command'
.Op Fl f
.Op Fl h
.Op Fl N Ar nodegroup1, nodegroup2, ...
.Op Fl w Ar node1, node2, ...
.Op Ar command
.Sh DESCRIPTION
.Nm
(the distributed shell) is a program which executes a single command
on multiple remote machines.  It can execute this command in parallel
(i.e. on any number of machines at a time) or in serial (by
specifying parallel execution of the command on 1 node at a time).
It was originally designed to work with rsh, but has full support for
ssh and with a little tweaking of the top part of
the script, should work with any program that allows remote execution
of a command without an interactive login.
.Pp
.Nm
takes a command and a set of nodes from the user; it checks the nodes
to make sure they can be contacted, and then runs the command on each node.
.Nm
displays the output (STDERR and STDOUT) of each
.Ar node
preceded by its name. The order the nodes are displayed is 
described in 
.Cm "A Brief Description of How dsh Removes Duplicates" ,
in the Section 
.Cm SPECIFYING NODES .
.Pp
.Nm
can also be run in interactive mode.  This mode is entered when the
user doesn't specify a command on the command line.  In this mode,
.Nm
will present the user with a prompt.  Here the user can enter a
command and 
.Nm
will run the command on the nodes that the user
specified when 
.Nm
was started.  After the command is run, the user
will again be presented with a prompt and can enter another command.  
It is important to note that this mode
does not actually log in to all of the nodes: it executes each command
separately using the remote execution program specified (typically
rsh or ssh).  An important consequence of this is that any properties
of a login shell, such as setting environment variables and job control, are 
not present.  Although
.Nm
does not actually log in to each node, commands entered at the 
.Nm
prompt are not interpreted by the local shell.  So entering 
echo $PATH at the 
.Nm
prompt 
.Pq Pa dsh> echo $PATH 
is different than entering echo
$PATH at the regular command line 
.Pq Pa dsh echo $PATH .  
In the first
case, the command echo $PATH is passed to the remote computer as is,
and so the PATH variable refers to the variable on
the remote machine.  In the second case, the variable PATH is first 
interpretted by the local shell, which replaces $PATH with the value
of PATH on the local machine before the command is passed to
the remote machine.  To simulate the first case at the regular
command line, use the -e switch 
.Pq Pa dsh -e 'echo $PATH' 
or quote the
variable to avoid interpolation by the local shell 
.Pq Pa dsh echo '$PATH' .
So, in short, commands typed at the
.Nm
prompt are executed as if for each node you typed 
.Pa rsh [remote computer] '[command you enter]' , 
where the command you enter is
placed in single quotes.  The 
.Nm
prompt does have command recall (up and down arrows) and editing 
(as featured in the GNU readline library).  Also, a local command 
can be executed by placing an exclamation point (!) in front 
of the command (e.g.
.Pa dsh> !ls 
runs ls on the local computer).
.Sh SPECIFYING NODES
There are 4 ways to specify where
.Nm
should execute a command:
.Ss -a
This switch adds all the nodes in the file
$BEOWULF_ROOT/node_groups/ALL, where ALL is a file specifying one node
per line (IP address or hostname).  Lines that begin with a # and
lines that have only whitespace are ignored.

.Pa example:
.nf
	  mtp6@front_end $ cat /util/beowulf/node_groups/ALL

	  front_end
	  # Linux nodes
	  linux1
	  linux2
	  penguin1
	  penguin2
	  # OpenBSD nodes
	  openbsd1
	  openbsd2
	  openbsd3
	  # FreeBSD nodes
	  freebsd1
	  freebsd2

	  mtp6@front_end $ dsh -a ls

.fi
This will run the command ls on front_end, linux1, linux2,
penguin1, penguin2, openbsd1, openbsd2, openbsd3, freebsd1, and
freebsd2
.Ss -N nodegroup1, nodegroup2, nodegroup3, ...
This switch adds all the nodes in the file
.br
$BEOWULF_ROOT/node_groups/nodegroup1 and all the nodes in the file
.br
$BEOWULF_ROOT/node_groups/nodegroup2, etc.
As with the ALL file,
the format of these nodegroup files is one node per line (IP address
or hostname).  Lines that begin with a # and lines that have only 
whitespace are ignored.

.Pa example:
.nf
	  mtp6@front_end $ cat /util/beowulf/node_groups/linux

	  # Linux part of the cluster, running Slackware 8.0, kernel 2.4.6
	  linux1
	  linux2
	  penguin1
	  penguin2

	  mtp6@front_end $ cat /util/beowulf/node_groups/openbsd

	  # OpenBSD part of the cluster, running OpenBSD 2.9
	  openbsd1
	  openbsd2
	  openbsd3

	  mtp6@front_end $ dsh -N linux, openbsd ls

.fi
This will run the command ls on linux1, linux2,
penguin1, penguin2, openbsd1, openbsd2, and openbsd3
.Ss -w node1, node2, node3, ...
This switch adds the nodes node1, node2, node3, etc.

.Pa example:
.nf
	  mtp6@front_end $ dsh -w freebsd1, freebsd2 ls

.fi
This will run the command ls on freebsd1 and freebsd2

.Pa example:
.nf
	  mtp6@front_end $ dsh -w 10.10.10.1, 10.10.10.2, 10.10.10.3 ls

.fi
This will run the command ls on 10.10.10.1, 10.10.10.2, and 10.10.10.3
.Ss WCOLL
If none of the above switches (-a, -N, -w) is specified, dsh defaults
to adding the nodes specified in the file pointed to by WCOLL.
.Nm
only looks at this environment variable when none of the 3 switches is
specified.

.Pa example:
.nf
	  mtp6@front_end $ export WCOLL=/home/mtp6/bsd

	  mtp6@front_end $ cat /home/mtp6/bsd

	  openbsd1
	  openbsd2
	  openbsd3
	  freebsd1
	  freebsd2

	  mtp6@front_end $ dsh ls

.fi
This will run the command ls on openbsd1, openbsd2, openbsd3, freebsd1, and
freebsd2
.Ss Combining -a, -N, and -w
You can combine the -a, -N, and -w switches in any order.

.Pa example:
.nf
	  mtp6@front_end $ dsh -N linux -w front_end ls

.fi
This will run the command ls on linux1, linux2, penguin1, penguin2,
and front_end
.Ss Duplicate Nodes
.Nm 
has a somewhat complicated way of dealing with duplicate nodes
.Pp
For example, if the node which has IP address 10.10.10.3 is called
linux3 and is aliased to tux3, then entering 
.Pa dsh -w linux3, tux3 ls
will only execute the command on 10.10.10.3 once.
Similarly,
.Pa dsh -w linux3, 10.10.10.3 ls
will only execute the command on 10.10.10.3 once.
.Pp
A more complicated example is a computer which has more than one
IP address.  For example, say front_end has a local IP address
10.10.10.254 and a remote IP address 128.205.83.101.  The following
commands are equivalent in that they will execute the command ls on
front_end only once (the IP address used to contact this node is the
first IP address returned by gethostbyname(3)):

.nf
	dsh -w front_end ls
	dsh -w 10.10.10.254 ls
	dsh -w 128.205.83.101 ls
	dsh -w front_end, 10.10.10.254 ls
	dsh -w 10.10.10.254, front_end ls
	dsh -w front_end, 128.205.83.101 ls
	dsh -w 128.205.83.101, front_end ls
	dsh -w front_end, 10.10.10.254, 128.205.83.101 ls
	dsh -w front_end, 128.205.83.101, 10.10.10.254 ls
	dsh -w 10.10.10.254, front_end, 128.205.83.101 ls
	dsh -w 128.205.83.101, front_end, 10.10.10.254 ls

.fi
In general, dsh will remove duplicates; however, there are cases where
dsh won't remove duplicates because it cannot tell from IP
addresses alone whether they refer to the same computer (i.e. dsh
doesn't do reverse name lookups when looking for duplicates).  For 
example, in the above scenario, the combinations which will
result in
.Nm
executing the command more than once are those which start with
the two IP addresses:

.nf
	dsh -w 10.10.10.254, 128.205.83.101 ls
	dsh -w 128.205.83.101, 10.10.10.254 ls
	dsh -w 10.10.10.254, 128.205.83.101, front_end ls
	dsh -w 128.205.83.101, 10.10.10.254, front_end ls
.fi

To see why, refer to the next section.

.Ss A Brief Description of How dsh Removes Duplicates 
.Nm
looks at each node, in the order of -w nodes first, and -a and -N
nodegroups second (the order of these last two depending on the order
they appear on the command line).  For each node,
.Nm 
resolves the name
to a set of IP addresses using 
.Pa gethostbyname(3) ; 
if any of these IP
addresses has already been seen, the node is removed from the list
(note: in the case of duplicates found in nodes specified by -a and
-N, the nodes are not removed from the actual files, they are only
removed from the current list, which is stored in RAM).

.Pa example:
.nf
	  mtp6@front_end $ dsh -w front_end, 128.205.83.101 ls

.fi
This will run the command on front_end only once because
.Nm
performs the following duplication analysis:  It looks at front_end
and resolves it into the IP addresses 10.10.10.254 and
128.205.83.101.  Neither of these IP addresses have been seen before,
so it doesn't remove front_end from the list.
.Nm
then looks at 128.205.83.101 and resolves it into the IP address
128.205.83.101.  This address has been seen before, so it removes
128.205.83.101 from the list.

.Pa example:
.nf
	mtp6@front_end $ dsh -w 10.10.10.254, 128.205.83.101 ls

.fi
This will run the command on front_end twice because
.Nm
performs the following duplication analysis:  It looks at 10.10.10.254
and resolves it into the IP address 10.10.10.254.  This IP address
hasn't been seen before, so it doesn't remove 10.10.10.254 from the
list.
.Nm 
then looks at 128.205.83.101 and resolves it into the IP address
128.205.83.101.  This address hasn't been seen before, so it doesn't
remove 128.205.83.101 from the list.

If you're not sure about duplicates, you can use the -q switch to see 
the list of nodes where
.Nm
would execute the command without actually executing the command.
.Sh ENVIRONMENT VARIABLES
.Ss
.Ss BEOWULF_ROOT
This is the directory that 
.Nm
uses to search for node groups
(specified with the -N switch) and the ALL file (specified with the -a
switch).  Note that whatever directory is specified in the variable
BEOWULF_ROOT must have a subdirectory called node_groups where the
nodegroup files and the ALL file are located.  
.br The default value of BEOWULF_ROOT is /util/beowulf
.Ss FANOUT
This is the number of nodes to run the command on in parallel.  The
default value is all of the nodes; however, you may wish to limit this
value if you have an extremely large number of nodes or if the machine
where you are running dsh from has a small amount of free resources.
For each node, 3 processes are forked, so to calculate the number of
processes running at one time, multiply FANOUT by 3 and add 1 (for
.Nm dsh )
.Ss WCOLL
See SPECIFYING NODE GROUPS
.Sh SWITCHES
.Bl -tag -width Ds
.It Fl N Ar nodegroup1, nodegroup2, ...
See SPECIFYING NODE GROUPS
.It Fl a
See SPECIFYING NODE GROUPS
.It Fl w Ar node1, node2, ...
See SPECIFYING NODE GROUPS
.It Fl q
Lists the nodes where dsh would execute the command without actually
executing the command
.It Fl e Ar 'command'
Executes the command in quotes on all the nodes.  The reason for this
switch is that putting the command to execute at the end of the
command line without single quotes can lead to metacharacter issues
(see 
.Cm QUOTING SHELL METACHARACTERS
below).  This way of specifying the commmand avoids this problem.
.It Fl t Ar (time in seconds)
Specifies the time to wait for a node to respond before labelling it
"unreachable".  The default value is 5.  Specifying 0 indicates no
timeout.
.It Fl f
If this flag is specified, 
.Nm
won't prompt the user whether or not to
continue if a node is unreachable or refusing a remote connection.
.Nm
will assume it should continue, bypassing the node. This is useful if
.Nm
is run in a non-interactive script.
.It Fl h
Displays a message containing a brief description of the command line
switches
.Sh QUOTING SHELL METACHARACTERS
When
.Nm
is used in the form
.Pa dsh [options] command ,
there is an issue with shell metacharacters.  That is, characters in
.Pa command 
are interpretted by the local shell before they are passed to
.Nm dsh .
For example, 
.Pa dsh -w 10.10.10.1, 10.10.10.2 find / -name 
.Pa bash > bash.find
will be interpretted as 'run dsh -w 10.10.10.1, 10.10.10.2 find /
-name bash and place the results of this program in the file
bash.find on the local computer'.  This does not run find / -name
bash on 10.10.10.1 and 10.10.10.2 and place the results of find 
in files named bash.find on the remote computers.  
To do that you would need to type
.Pa dsh -w 10.10.10.1, 10.10.10.2 find / -name 
.Pa bash '>' bash.find 
to avoid interpretation of > by the local shell.  Another way to avoid
local metacharacter interpretation is to use the -e switch: 
.Pa dsh -w 10.10.10.1, 10.10.10.2 -e 'find / -name 
.Pa bash > bash.find' .
I highly recommend using the -e switch to execute commands or running
dsh in interactive mode because most modern shells have many 
metacharacters and quoting these can be tricky even if you 
recognize all of them.
.Sh EXIT CODES
If 
.Nm
exits cleanly (that is, if 
.Nm
is allowed to call exit itself),
the exit code of 
.Nm
will either be a 0 or a 1.  0 indicates that
.Nm
at least ran the command "rsh (node) command" for every non-duplicate
node.  Note that an exit code of 0 does not mean that every rsh was 
successful nor does it mean that the command exited with a code of 
0 on the remote computer :-\\ . The way 
.Nm
executes the rsh command doesn't lend itself to
capturing its exit code.  An exit code of 1 indicates
that 
.Nm
did not attempt to run the command on any remote computers 
because of an error.
.Sh WEBSITE
http://dsh.sourceforge.net
.Sh AUTHORS
.Nm
was originally written by Jason Rappleye at the Center for
Computational Research at the University at Buffalo.  Version 2.0 was
written by Matthew T. Piotrowski at the Center for Computational
Research.  Thanks to dale@bewley.net for his contributions to the
early stages of version 2.0.  This manpage was written by Matthew
T. Piotrowski. The OpenSSH manpage (ssh.1), version 1.99, was used as an nroff
reference.
.Sh SEE ALSO
.Xr rsh 1 ,
.Xr gethostbyname 3 ,
.Xr ssh 1
